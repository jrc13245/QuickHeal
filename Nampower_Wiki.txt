Manual Configuration

The following CVars control the behavior of the spell queuing system:

You can access CVars in game with /run DEFAULT_CHAT_FRAME:AddMessage(GetCVar("CVarName"))
and set them with /run SetCVar("CVarName", "Value")

You can also just place them in your Config.wtf file in your WTF folder. If they are the default value they will not be written to the file. Example:

SET EnableMusic "0"
SET MasterSoundEffects "0"

SET NP_QuickcastTargetingSpells "1"
SET NP_SpellQueueWindowMs "1000"
SET NP_TargetingQueueWindowMs "1000"

    NP_QueueCastTimeSpells - Whether to enable spell queuing for spells with a cast time. 0 to disable, 1 to enable. Default is 1.

    NP_QueueInstantSpells - Whether to enable spell queuing for instant cast spells tied to gcd. 0 to disable, 1 to enable. Default is 1.

    NP_QueueChannelingSpells - Whether to enable channeling spell queuing as well as whether to allow any queuing during channels. 0 to disable, 1 to enable. Default is 1.

    NP_QueueTargetingSpells - Whether to enable terrain targeting spell queuing. 0 to disable, 1 to enable. Default is 1.

    NP_QueueOnSwingSpells - Whether to enable on swing spell queuing. 0 to disable, 1 to enable. Default is 0 (changed with 1.17.2 due to changes to on swing spells).

    NP_QueueSpellsOnCooldown - Whether to enable queuing for spells coming off cooldown. 0 to disable, 1 to enable. Default is 1.

    NP_InterruptChannelsOutsideQueueWindow - Whether to allow interrupting channels (the original client behavior) when trying to cast a spell outside the channeling queue window. Default is 0.

    NP_SpellQueueWindowMs - The window in ms before a cast finishes where the next will get queued. Default is 500.

    NP_OnSwingBufferCooldownMs - The cooldown time in ms after an on swing spell before you can queue on swing spells. Default is 500.

    NP_ChannelQueueWindowMs - The window in ms before a channel finishes where the next will get queued. Default is 1500.

    NP_TargetingQueueWindowMs - The window in ms before a terrain targeting spell finishes where the next will get queued. Default is 500.

    NP_CooldownQueueWindowMs - The window in ms of remaining cooldown where a spell will get queued instead of failing with 'Spell not Ready Yet'. Default is 250.

    NP_MinBufferTimeMs - The minimum buffer delay in ms added to each cast (covered more below). The dynamic buffer adjustments will not go below this value. Default is 55.

    NP_NonGcdBufferTimeMs - The buffer delay in ms added AFTER each cast that is not tied to the gcd. Default is 100.

    NP_MaxBufferIncreaseMs - The maximum amount of time in ms to increase the buffer by when the server rejects a cast. This prevents getting too long of a buffer if you happen to get a ton of rejections in a row. Default is 30.

    NP_RetryServerRejectedSpells - Whether to retry spells that are rejected by the server for these reasons: SPELL_FAILED_ITEM_NOT_READY, SPELL_FAILED_NOT_READY, SPELL_FAILED_SPELL_IN_PROGRESS. 0 to disable, 1 to enable. Default is 1.

    NP_QuickcastTargetingSpells - Whether to enable quick casting for ALL spells with terrain targeting. This will cause the spell to instantly cast on your cursor without waiting for you to confirm the targeting circle. Queuing targeting spells will use quickcasting regardless of this value (couldn't get it to work without doing this). 0 to disable, 1 to enable. Default is 0.

    NP_ReplaceMatchingNonGcdCategory - Whether to replace any queued non gcd spell when a new non gcd spell with the same StartRecoveryCategory is cast (more explanation below). 0 to disable, 1 to enable. Default is 0.

    NP_OptimizeBufferUsingPacketTimings - Whether to attempt to optimize your buffer using your latency and server packet timings (more explanation below). 0 to disable, 1 to enable. Default is 0.

    NP_PreventRightClickTargetChange - Whether to prevent right-clicking from changing your current target when in combat. If you don't have a target right click will still change your target even with this on. This is mainly to prevent accidentally changing targets in combat when trying to adjust your camera. 0 to disable, 1 to enable. Default is 0.

    NP_PreventRightClickPvPAttack - Whether to prevent right-clicking on PvP flagged players to avoid accidental PvP attacks. 0 to disable, 1 to enable. Default is 1.

    NP_DoubleCastToEndChannelEarly - Whether to allow double casting a spell within 350ms to end channeling on the next tick. Takes into account your ChannelLatencyReductionPercentage. 0 to disable, 1 to enable. Default is 0.

    NP_SpamProtectionEnabled - Whether to enable spam protection functionality that blocks spamming spells while waiting for the server to respond to your initial cast due to issues spamming can cause. 0 to disable, 1 to enable. Default is 1.

    NP_ChannelLatencyReductionPercentage - The percentage of your latency to subtract from the end of a channel duration to optimize cast time while hopefully not losing any ticks (more explanation below). Default is 75.

    NP_NameplateDistance - The distance in yards to display nameplates. Defaults to whatever was set by the game or vanilla tweaks.

Existing Lua Changes
Improved flexibility on spellbook Lua functions

These built-in Lua spell APIs now accept any of the following as their first argument: 1) spell slot (original behavior), 2) spell name, or 3) spellId:number.

Name and spellId lookups are cached internally and validated against current spellbook contents before reuse so you don't have to worry about performance implications or issues after respec'ing.

See examples below for differences in how BOOKTYPE works.

Functions: GetSpellTexture, GetSpellName, GetSpellCooldown, GetSpellAutocast, ToggleSpellAutocast, PickupSpell, CastSpell, IsCurrentCast, IsSpellPassive.

Examples:

/run print(GetSpellTexture(1, "spell")) -- booktype required
/run print(GetSpellTexture("spellId:25978")) -- defaults to BOOKTYPE_SPELL
/run print(GetSpellTexture("spellId:6268", "pet")) -- "pet" needed for pet spells
/run print(GetSpellTexture("Fireball")) -- name search

Custom Lua Functions
Spell/Item/Unit information
GetItemStats(itemId)

Returns a Lua table containing all fields for the item's ItemStats record (including localized displayName and description). Returns nil if the item cannot be found or loaded.

Full field name lists are in DBC_FIELDS.md.
GetItemStatsField(itemId, fieldName)

Fast lookup for a single field on an item. Returns the requested field value; returns nil if the item is not found; raises a Lua error if the field name is invalid.

Full field name lists are in DBC_FIELDS.md.

Examples:

-- Get item name
local name = GetItemStatsField(19019, "displayName")
print(name) -- "Thunderfury, Blessed Blade of the Windseeker"

-- Get item level
local ilvl = GetItemStatsField(22589, "itemLevel")
print("Atiesh item level: " .. ilvl) -- 90

-- Get item quality (0=Poor, 1=Common, 2=Uncommon, 3=Rare, 4=Epic, 5=Legendary)
local quality = GetItemStatsField(19019, "quality")
print("Quality: " .. quality) -- 5 (Legendary)

-- Get item delay (weapon speed in milliseconds)
local delay = GetItemStatsField(19019, "delay")
print("Weapon speed: " .. (delay / 1000) .. " seconds") -- 1.9 seconds

GetSpellRec(spellId)

Returns a Lua table containing all fields for the spell's SpellRec record (including localized name and rank). Returns nil if the spell cannot be found.

Full field name lists are in DBC_FIELDS.md.
GetSpellRecField(spellId, fieldName)

Fast lookup for a single field on a spell. Returns the requested field value; returns nil if the spell is not found; raises a Lua error if the field name is invalid.

Full field name lists are in DBC_FIELDS.md.

Examples:

-- Get spell name
local name = GetSpellRecField(116, "name")
print(name) -- "Frostbolt"

-- Get spell rank
local rank = GetSpellRecField(116, "rank")
print(rank) -- "Rank 1"

-- Get spell cast time in milliseconds
local castTime = GetSpellRecField(133, "castTime")
print("Fireball cast time: " .. (castTime / 1000) .. " seconds") -- 3.5 seconds

-- Get spell range (max range in yards * 10, so divide by 10)
local maxRange = GetSpellRecField(116, "rangeMax")
print("Frostbolt max range: " .. (maxRange / 10) .. " yards") -- 30 yards

-- Get spell mana cost
local manaCost = GetSpellRecField(116, "manaCost")
print("Mana cost: " .. manaCost)

-- Get spell school (0=Physical, 1=Holy, 2=Fire, 3=Nature, 4=Frost, 5=Shadow, 6=Arcane)
local school = GetSpellRecField(116, "school")
print("School: " .. school) -- 4 (Frost)

-- Get spell icon ID
local spellIconID = GetSpellRecField(116, "spellIconID")
print("Icon ID: " .. spellIconID)

GetSpellModifiers(spellId, modifierType)

Returns the current spell modifiers applied to a spell for the player. This includes buffs, talents, and other effects that modify spell behavior.

Parameters:

    spellId (number): The spell ID to check
    modifierType (number): The type of modifier to check (see list below)

Returns:

    1st param (number): Flat modification value (e.g., +50 damage)
    2nd param (number): Percent modification value (e.g., 10 for +10%)
    3rd param (number): Return value from the function (whether there was any percent or flat modifier)

Modifier Types:

    0 = DAMAGE
    1 = DURATION
    2 = THREAT
    3 = ATTACK_POWER
    4 = CHARGES
    5 = RANGE
    6 = RADIUS
    7 = CRITICAL_CHANCE
    8 = ALL_EFFECTS
    9 = NOT_LOSE_CASTING_TIME
    10 = CASTING_TIME
    11 = COOLDOWN
    12 = SPEED
    14 = COST
    15 = CRIT_DAMAGE_BONUS
    16 = RESIST_MISS_CHANCE
    17 = JUMP_TARGETS
    18 = CHANCE_OF_SUCCESS
    19 = ACTIVATION_TIME
    20 = EFFECT_PAST_FIRST
    21 = CASTING_TIME_OLD
    22 = DOT
    23 = HASTE
    24 = SPELL_BONUS_DAMAGE
    27 = MULTIPLE_VALUE
    28 = RESIST_DISPEL_CHANCE

Example:

-- Check damage modifiers on Frostbolt (spell ID 116)
local flatMod, percentMod, ret = GetSpellModifiers(116, 0)
print("Flat damage bonus: " .. flatMod)
print("Percent damage bonus: " .. percentMod .. "%")

GetUnitData(unitToken)

Returns a Lua table containing all unit fields for the specified unit. This provides access to low-level unit data like health, mana, stats, auras, resistances, and more.

Parameters:

    unitToken (string): Can be a standard unit token ("player", "target", "pet", "mouseover", etc.) or a GUID string (e.g., "0xF5300000000000A5")

Returns:

    A Lua table containing all unit fields, or nil if the unit cannot be found

Full field name lists are in UNIT_FIELDS.md.

Example:

-- Get all unit data for your current target
local data = GetUnitData("target")
if data then
    print("Target health: " .. data.health .. "/" .. data.maxHealth)
    print("Target level: " .. data.level)
    print("Target display ID: " .. data.displayId)
end

-- Using a GUID
local data = GetUnitData("0xF5300000000000A5")

GetUnitField(unitToken, fieldName)

Fast lookup for a single field on a unit. More efficient than GetUnitData when you only need one specific field.

Parameters:

    unitToken (string): Can be a standard unit token ("player", "target", "pet", "mouseover", etc.) or a GUID string
    fieldName (string): The name of the field to retrieve

Returns:

    The requested field value; returns nil if the unit is not found; raises a Lua error if the field name is invalid
    For array fields (like "aura", "resistances"), returns a Lua table with numeric indices

Full field name lists are in UNIT_FIELDS.md.

Examples:

-- Get target's current health
local health = GetUnitField("target", "health")
print("Target health: " .. health)

-- Get player's current mana (power1)
local mana = GetUnitField("player", "power1")
print("Player mana: " .. mana)

-- Get all auras on target (returns a table)
local auras = GetUnitField("target", "aura")
for i, auraId in ipairs(auras) do
    print("Aura " .. i .. ": " .. auraId)
end

-- Get all resistances (returns a table)
local resistances = GetUnitField("player", "resistances")
-- resistances[1] = armor, [2] = holy, [3] = fire, [4] = nature, [5] = frost, [6] = shadow, [7] = arcane

QueueSpellByName(spellName)

Will force queue a spell regardless of the appropriate queue window. If no spell is currently being cast it will be cast immediately. For example can make a macro with

/run QueueSpellByName("Frostbolt");QueueSpellByName("Frostbolt")

to cast 2 frostbolts in a row. Currently, can only queue 1 GCD spell at a time and 5 non gcd spells. This means you can't do 3 frostbolts in a row with one macro.
CastSpellByNameNoQueue(spellName)

Will force a spell cast to never queue even if your settings would normally queue. Can be used to fix addons that don't work with queued spells.
QueueScript(script, [priority])

Queues any arbitrary script using the same logic as a regular spell using NP_SpellQueueWindowMs as the window. If no spell is being cast and you are not on the gcd the script will be run immediately.

Priority is optional and defaults to 1.
Priority 1 means the script will run before any other queued spells. Priority 2 means the script will run after any queued non gcd spells but before any queued normal spells. Priority 3 means the script will run after any type of queued spells.

Convert slash commands from other addons like /equip to their function form SlashCmdList.EQUIP to use them inside QueueScript.

For example, you can equip a libram before casting a queued heal using

/run QueueScript('SlashCmdList.EQUIP("Libram of +heal")')

IsSpellInRange(spellName, [target]) or IsSpellInRange(spellId, [target])

Takes a spell name or spell id and an optional target. Target can the usual UNIT tokens like "player", "target", "mouseover", etc or a unit guid.

If using spell name it must be a spell you have in your spellbook. If using spell id it can be any spell id.

Returns 1 if the spell is in range, 0 if not in range, and -1 if the spell is not valid for this check (must be TARGET_UNIT_PET, TARGET_UNIT_TARGET_ENEMY, TARGET_UNIT_TARGET_ALLY, TARGET_UNIT_TARGET_ANY). This is because this uses the same underlying function as IsActionInRange which returns 1 for spells that are not single target which can be misleading.

Examples:

/run local result=IsSpellInRange("Frostbolt"); if result == 1 then print("In range") else if result == 0 then print("Out of range") else print("Not single target") end

IsSpellUsable(spellName) or IsSpellUsable(spellId)

Takes a spell name or spell id.

Usable does not equal castable. This is most often used to check if a reactive spell is usable.

If using spell name it must be a spell you have in your spellbook. If using spell id it can be any spell id.

Returns:

1st param: 1 if the spell is usable, 0 if not usable. 2nd param: Always 0 if spell is not usable for a different reason other than mana. 1 if out of mana, 0 if not out of mana.

Examples:

/run local result=IsSpellUsable("Frostbolt"); if result == 1 then print("Frostbolt usable") else print("Frostbolt not usable") end

GetCurrentCastingInfo()

Returns:

1st param: Casting spell id or 0 2nd param: Visual spell id or 0. This won't always get cleared after a spell finishes. 3rd param: Auto repeating spell id or 0. 4th param: 1 if casting spell with a cast time, 0 if not. 5th param: 1 if channeling, 0 if not. 6th param: 1 if on swing spell is pending, 0 if not. 7th param: 1 if auto attacking, 0 if not.

For normal spells these will be the same. For some spells like auto-repeating and channeling spells only the visual spell id will be set.

Examples:

/run local castId,visId,autoId,casting,channeling,onswing,autoattack=GetCurrentCastingInfo();print(castId);print(visId);print(autoId);print(casting);print(channeling);print(onswing);print(autoattack);

GetSpellIdForName(spellName)

Returns:

1st param: the max rank spell id for a spell name if it exists in your spellbook. Returns 0 if the spell is not in your spellbook.

Examples:

/run local spellId=GetSpellIdForName("Frostbolt");print(spellId)
/run local spellId=GetSpellIdForName("Frostbolt(Rank 1)");print(spellId)

GetSpellNameAndRankForId(id)

Returns:

1st param: the spell name for a spell id 2nd param: the spell rank for a spell id as a string such as "Rank 1"

Examples:

/run local spellName,spellRank=GetSpellNameAndRankForId(116);print(spellName);print(spellRank)
prints "Frostbolt" and "Rank 1"

GetSpellSlotTypeIdForName(spellName)

Returns:

1st param: the 1 indexed (lua calls expect this) spell slot number for a spell name if it exists in your spellbook. Returns 0 if the spell is not in your spellbook. 2nd param: the book type of the spell, either "spell", "pet" or "unknown". 3rd param: the spell id of the spell. Returns 0 if the spell is not in your spellbook.

Examples:

/run local slot, bookType, spellId=GetSpellSlotTypeIdForName("Frostbolt");print(slot);print(bookType);print(spellId)

GetNampowerVersion()

Returns the current version of Nampower split into major, minor and patch numbers.

So if version was v2.8.6 it would return 2, 8, 6 as integers.

Examples:

/run local major, minor, patch=GetNampowerVersion();print(major);print(minor);print(patch)

The previous version of this GetSpellSlotAndTypeForName was removed as it was returning a 0 indexed slot number which was confusing to use in lua.
GetItemLevel(itemId)

Returns the item level of an item. Returns an error if the item id is invalid.

Examples:

/run local itemLevel=GetItemLevel(22589);print(itemLevel)
should print 90 for atiesh

ChannelStopCastingNextTick()

Will stop channeling early on the next tick if you have queue channeling spells enabled and try to cast a spell before the next tick (didn't know how to cancel channels without casting another spell). Uses your ChannelLatencyReductionPercentage to determine when to stop the channel.
Custom Events
SPELL_QUEUE_EVENT

I've added a new event you can register in game to get updates when spells are added and popped from the queue.

The event is SPELL_QUEUE_EVENT and has 2 parameters:

    int eventCode - see below
    int spellId

Possible Event codes:

 ON_SWING_QUEUED = 0
 ON_SWING_QUEUE_POPPED = 1
 NORMAL_QUEUED = 2
 NORMAL_QUEUE_POPPED = 3
 NON_GCD_QUEUED = 4
 NON_GCD_QUEUE_POPPED = 5

Example from NampowerSettings:

local ON_SWING_QUEUED = 0
local ON_SWING_QUEUE_POPPED = 1
local NORMAL_QUEUED = 2
local NORMAL_QUEUE_POPPED = 3
local NON_GCD_QUEUED = 4
local NON_GCD_QUEUE_POPPED = 5

local function spellQueueEvent(eventCode, spellId)
	if eventCode == NORMAL_QUEUED or eventCode == NON_GCD_QUEUED then
		local _, _, texture = SpellInfo(spellId) -- superwow function
		Nampower.queued_spell.texture:SetTexture(texture)
		Nampower.queued_spell:Show()
	elseif eventCode == NORMAL_QUEUE_POPPED or eventCode == NON_GCD_QUEUE_POPPED then
		Nampower.queued_spell:Hide()
	end
end

NampowerSettings:RegisterEvent("SPELL_QUEUE_EVENT", spellQueueEvent)

SPELL_CAST_EVENT

New event you can register in game to get updates when spells are cast with some additional information.

The event is SPELL_CAST_EVENT and has 5 parameters:

    int success - 1 if cast succeeded, 0 if failed
    int spellId
    int castType - see below
    string targetGuid - guid string like "0xF5300000000000A5"
    int itemId - the id of the item that triggered the spell, 0 if it wasn't triggered by an item

Possible Cast Types:

NORMAL=1
NON_GCD=2
ON_SWING=3
CHANNEL=4
TARGETING=5 (targeting is the term I used for spells with terrain targeting)
TARGETING_NON_GCD=6

targetGuid will be "0x000000000" unless an explicit target is specified which currently only happens in 2 circumstances:

    It was specified as the 2nd param of CastSpellByName (added by superwow)
    Mouseover casts that use SpellTargetUnit to specify a target

Example (uses ace RegisterEvent):

Cursive:RegisterEvent("SPELL_CAST_EVENT", function(success, spellId, castType, targetGuid, itemId)
	print(success)
	print(spellId)
	print(castType)
	print(targetGuid)
	print(itemId)
end);

SPELL_DAMAGE_EVENT_SELF and SPELL_DAMAGE_EVENT_OTHER

New events you can register in game to get updates whenever spell damage occurs. SPELL_DAMAGE_EVENT_SELF will only trigger for damage you deal, while SPELL_DAMAGE_EVENT_OTHER will only trigger for damage dealt by others.

Both of these events have the following parameters:

    string targetGuid - guid string like "0xF5300000000000A5"
    string casterGuid - guid string like "0xF5300000000000A5"
    int spellId
    int amount - the amount of damage dealt. If the 4th value in effectAuraStr is 89 (SPELL_AURA_PERIODIC_DAMAGE_PERCENT) I believe this is the percentage of health lost.
    string mitigationStr - comma separated string containing "aborb,block,resist" amounts
    int hitInfo - see below but generally 0 unless the spell was a crit in which case it will be 2
    int spellSchool - the damage school of the spell, see below
    string effectAuraStr - comma separated string containing the three spell effect numbers and the aura type (usually means a Dot but not all Dots will have an aura type) if applicable. So "effect1,effect2,effect3,auraType"

Spell hit info enum: 94f05231d4/src/game/Spells/SpellDefines.h (L109)

Spell school enum: 94f05231d4/src/game/Spells/SpellDefines.h (L641)

Spell effect enum: 94f05231d4/src/game/Spells/SpellDefines.h (L142)

Aura type enum: 94f05231d4/src/game/Spells/SpellAuraDefines.h (L43)

Example (uses ace RegisterEvent):

Cursive:RegisterEvent("SPELL_DAMAGE_EVENT_SELF",
    function(targetGuidStr,
             casterGuidStr,
             spellId,
             amount,
             mitigationStr,
             hitInfo,
             spellSchool,
             effectAuraStr)
        print(targetGuidStr .. " " .. casterGuidStr .. " " .. tostring(spellId) .. " " .. tostring(amount) .. " " .. tostring(spellSchool) .. " " .. mitigationStr .. " " .. hitInfo .. " " .. effectAuraStr)
    end);

There are separate configurable queue windows for:

    Normal spells
    On swing spells (the window functions as a cooldown instead where you cannot immediately double queue on swing spells so that I don't have to track swing timers)
    Channeling spells
    Spells with terrain targeting

There are 3 separate queues for the following types of spells: GCD(max size:1), non GCD(max size:6), and on-hit(max size:1).

Additionally the queuing system will ignore spells with any of the following attributes/effects to avoid issues with tradeskills/enchants/other out of combat activities:

    SpellAttributes::SPELL_ATTR_TRADESPELL
    SpellEffects::SPELL_EFFECT_TRADE_SKILL
    SpellEffects::SPELL_EFFECT_ENCHANT_ITEM
    SpellEffects::SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY
    SpellEffects::SPELL_EFFECT_CREATE_ITEM
    SpellEffects::SPELL_EFFECT_OPEN_LOCK
    SpellEffects::SPELL_EFFECT_OPEN_LOCK_ITEM

Why do I need a buffer?

From my own testing it seems that a buffer is required on spells to avoid "This ability isn't ready yet"/"Another action in progress" errors.
By that I mean that if you cast a 1.5 second cast time spell every 1.5 seconds without your ping changing you will occasionally get errors from the server and your cast will get rejected. If you have 150ms+ ping this can be very punishing.

I believe this is related to the server tick during which incoming spells are processed. There is logic to subtract the server processing time from your gcd in vmangos but other servers do not appear to be doing this.

To compensate for what seems to be a 50ms server tick the default buffer in nampower.cfg is 55ms. If you are close to the server you can experiment with lowering this value. You will occasionally get errors but if they are infrequent enough for you the time saved will be worth it.

Non gcd spells also seem to be affected by this. I suspect that only one spell can be processed per server tick.
This means that if you try to cast 2 non gcd spells in the same server tick only one will be processed.
To avoid this happening there is NP_NonGcdBufferTimeMs which is added after each non gcd spell. There might be more to it than this as using the normal buffer of 55ms was still resulting in skipped casts for me. I found 100ms to be a safe value.
GCD Spells

Only one gcd spell can be queued at a time. Pressing a new gcd spell will replace any existing queued gcd spell.

As of 5/13/2025 the server tick is now subtracted from the gcd timer so a buffer is no longer required for spells with a cast time at least ~50ms less than their gcd :)
Non GCD Spells

Non gcd spells have special handling. You can queue up to 6 non gcd spells, and they will execute in the order queued with NP_NonGcdBufferTimeMs delay after each of them to help avoid server rejection.
The non gcd queue always has priority over queued normal spells.
You can only queue a given spellId once in the non gcd queue, any subsequent attempts will just replace the existing entry in the queue.

NP_ReplaceMatchingNonGcdCategory will cause non gcd spells with the same non zero StartRecoveryCategory to replace each other in the queue.
The vast majority of spells not on the gcd have category '0' so it ignores them to avoid causing issues.
One notable exception is shaman totems that were changed to have separate categories according to their elements.

This can be useful if you want to change your mind about the non gcd spell you have queued. For example, if you queue a mana potion and decide you want to use LIP instead last minute.
On hit Spells

Only one on hit spell can be queued at a time. Pressing a new on hit spell will replace any existing queued on hit spell.
On hit spells have no effect on the gcd or non gcd queues as they are handled entirely separately and are resolved by your auto attack.
Channeling Spells

Channeling spells function differently than other spells in that the channel in the client actually begins when you receive the CHANNEL_START packet from the server. This means the client channel is happening 1/2 your latency after the server channel and that server tick delay is already included in the cast, whereas regular spells are the other way around (the client is ahead of the server).

From my testing it seems that you can usually subtract your full latency from the end of the channel duration without losing any ticks. Since your latency can vary it is safer to do a percentage of your latency instead to minimize the chance of having a tick cut off. This is controlled by the cvar NP_ChannelLatencyReductionPercentage which defaults to 75.

Channeling spells can be interrupted outside the channel queue window by casting any spell if NP_InterruptChannelsOutsideQueueWindow is set to 1. During the channel queue window you cannot interrupt the channel unless you turn off NP_QueueChannelingSpells. You can always move to interrupt a channel at any time.
Spells on Cooldown

If using NP_QueueSpellsOnCooldown when you attempt to cast a spell that has a remaining cooldown of less than NP_CooldownQueueWindowMs it will be queued instead of failing with 'Spell not Ready Yet'. There is a separate queue of size 1 for normal spells and non gcd spells. If something is in either of these cooldown queues and you try to cast a spell that is not on cooldown it will be cast immediately and clear the appropriate cooldown queue.

For example, if Fire Blast is on cooldown and I queue it and then try to cast Fireball it will cast Fireball immediately and Fire Blast will not get automatically cast anymore.

This currently doesn't work for item cooldowns as they work differently, will add in the future.
NP_OptimizeBufferUsingPacketTimings

This feature will attempt to optimize your buffer on individual casts using your latency and server packet timings.
After you begin to cast a spell you will get a cast result packet back from the server letting you know if the cast was successful. The time between when you send your start cast packet and when you receive the cast result packet consists of:

    The time it takes for your packet to reach the server
    The time it takes for the server to process the packet (see Why do I need a buffer?)
    The time it takes for the server to send the result packet back to you
    Other delays I'm not sure about like the time it takes for the client to process packets from the server due to being single threaded

If we take this 'Spell Response Time' and subtract your regular latency from it, we should be able to get a rough idea of the time it took for the server to process the cast. If that time was less than your current default buffer we can use that time as the new buffer for the next cast only. In theory if it is more than your current buffer we should also use it, but in practice it seems to regularly be way larger than expected and using the default buffer doesn't result in an error.

Due to this delay varying wildly in testing I'm unsure how reliable this technique is. It needs more testing and a better understanding of all the factors introducing delay. It is disabled by default for now.

--------------------------------------------------------------------------------------------------
DBC_FIELDS.md
-------------------------------------------------------------------------------------------------
DBC Field Names
Related structs live in nampower/game.hpp (notably SpellRec and ItemStats_C).
ItemStats_C Fields (alphabetical)
allowableClass
allowableRace
ammoType
area
bagFamily
block
bonding
buyPrice
class
containerSlots
delay
displayInfoID
duration
flags
inventoryType
itemLevel
itemSet
languageID
lockID
map
material
maxCount
maxDurability
pageMaterial
pageText
quality
randomProperty
rangedModRange
requiredCityRank
requiredHonorRank
requiredLevel
requiredRep
requiredRepRank
requiredSkill
requiredSkillRank
requiredSpell
sellPrice
sheatheType
stackable
startQuestID
subclass
ItemStats_C Array Fields (alphabetical)
bonusAmount
bonusStat
damageType
maxDamage
minDamage
resistances
spellCategory
spellCategoryCooldown
spellCharges
spellCooldown
spellID
spellTrigger
SpellRec Fields (alphabetical)
activeIconID
attributes
attributesEx
attributesEx2
attributesEx3
attributesEx4
auraInterruptFlags
baseLevel
castUI
category
categoryRecoveryTime
casterAuraState
castingTimeIndex
channelInterruptFlags
dispel
dmgClass
durationIndex
equippedItemClass
equippedItemInventoryTypeMask
equippedItemSubClassMask
id
interruptFlags
manaCost
manaCostPercentage
manaCostPerlevel
manaPerSecond
manaPerSecondPerLevel
maxAffectedTargets
maxLevel
maxTargetLevel
mechanic
minFactionId
minReputation
modalNextSpell
powerType
preventionType
procChance
procCharges
procFlags
rangeIndex
recoveryTime
requiredAuraVision
school
spellFamilyFlags
spellFamilyName
spellIconID
spellLevel
spellPriority
spellVisual
spellVisual2
stackAmount
stances
stancesNot
startRecoveryCategory
startRecoveryTime
targetAuraState
targetCreatureType
targets
SpellRec Array Fields (alphabetical)
dmgMultiplier
effect
effectAmplitude
effectApplyAuraName
effectBaseDice
effectBasePoints
effectChainTarget
effectDicePerLevel
effectDieSides
effectImplicitTargetA
effectImplicitTargetB
effectItemType
effectMechanic
effectMiscValue
effectMultipleValue
effectPointsPerComboPoint
effectRadiusIndex
effectRealPointsPerLevel
effectTriggerSpell
reagent
reagentCount
totem

--------------------------------------------------------------------------------------------------
UNIT_FIELDS.md
-------------------------------------------------------------------------------------------------
Unit Fields Reference
This document lists all available unit fields that can be accessed via GetUnitData() and GetUnitField() functions.
Overview
Unit fields provide low-level access to game data for any unit (player, target, pet, NPCs, etc.). These fields are part of the WoW 1.12 client's internal data structures.
Usage
-- Get all fields at once
local data = GetUnitData("target")
if data then
    print("Health: " .. data.health)
end

-- Get a single field (more efficient)
local health = GetUnitField("target", "health")
Simple Fields
These fields return a single value (number).
Object References (UINT64)
These fields contain GUIDs (globally unique identifiers) for game objects:
charm - GUID of the unit that has charmed this unit
summon - GUID of the unit's current summon
charmedBy - GUID of the unit that charmed this unit
summonedBy - GUID of the unit that summoned this unit
createdBy - GUID of the unit that created this unit
target - GUID of the unit's current target
persuaded - GUID of the unit being persuaded
channelObject - GUID of the object being channeled (for channeling spells)
Health and Power (UINT32)
health - Current health points
power1 - Current mana (or energy/rage depending on class)
power2 - Current rage
power3 - Current focus (hunter pets)
power4 - Current energy (rogues, druids in cat/bear form)
power5 - Current happiness (hunter pets)
maxHealth - Maximum health points
maxPower1 - Maximum mana
maxPower2 - Maximum rage
maxPower3 - Maximum focus
maxPower4 - Maximum energy
maxPower5 - Maximum happiness
Basic Unit Info (UINT32)
level - Unit's level
factionTemplate - Unit's faction template ID
flags - Unit flags (combat, dead, mounted, etc.)
dynamicFlags - Dynamic unit flags (lootable, tapped, etc.)
auraState - Aura state flags (reactive abilities like Revenge, Overpower)
npcFlags - NPC flags (vendor, trainer, quest giver, etc.)
npcEmoteState - Current emote state ID
Display and Appearance (UINT32)
displayId - Current display model ID
nativeDisplayId - Original/native display model ID
mountDisplayId - Mount display model ID (if mounted)
Combat Stats (UINT32)
baseAttackTime - Base main-hand attack time in milliseconds
offhandAttackTime - Off-hand attack time in milliseconds
rangedAttackTime - Ranged attack time in milliseconds
Combat Stats (FLOAT)
boundingRadius - Unit's bounding radius for collision
combatReach - Unit's combat reach distance
minDamage - Minimum main-hand damage
maxDamage - Maximum main-hand damage
minOffhandDamage - Minimum off-hand damage
maxOffhandDamage - Maximum off-hand damage
minRangedDamage - Minimum ranged damage
maxRangedDamage - Maximum ranged damage
Pet Info (UINT32)
petNumber - Pet's number identifier
petNameTimestamp - Timestamp of pet name
petExperience - Pet's current experience
petNextLevelExp - Experience needed for pet's next level
Spell/Channel Info (UINT32)
channelSpell - Spell ID of currently channeling spell
createdBySpell - Spell ID that created this unit (for summons)
Casting Speed (FLOAT)
modCastSpeed - Cast speed modifier (1.0 = normal, <1.0 = faster, >1.0 = slower)
Training (UINT32)
trainingPoints - Available training points (for pets and talents)
Base Stats (UINT32)
stat0 - Strength
stat1 - Agility
stat2 - Stamina
stat3 - Intellect
stat4 - Spirit
baseMana - Base mana before modifiers
baseHealth - Base health before modifiers
Attack Power (UINT32)
attackPower - Total melee attack power
attackPowerMods - Attack power modifiers
rangedAttackPower - Total ranged attack power
rangedAttackPowerMods - Ranged attack power modifiers
Attack Power Multipliers (FLOAT)
attackPowerMultiplier - Melee attack power multiplier
rangedAttackPowerMultiplier - Ranged attack power multiplier
Packed Byte Fields (UINT32)
These are special fields that pack multiple values into a single 32-bit integer:
bytes0 - Contains race, class, gender, and power type
Byte 0: Race
Byte 1: Class
Byte 2: Gender
Byte 3: Power type
bytes1 - Contains stand state, pet talent points, vis flags, and anim tier
Byte 0: Stand state
Byte 1: Pet talent points
Byte 2: Vis flags
Byte 3: Anim tier
bytes2 - Contains sheath state, pvp flags, pet flags, and shape shift form
Byte 0: Sheath state
Byte 1: PvP flags
Byte 2: Pet flags
Byte 3: Shape shift form
Array Fields
These fields return a Lua table with numeric indices (1-based).
Visual Items (UINT32 arrays)
virtualItemDisplay [3] - Display IDs for virtual items (weapon visuals, etc.)
virtualItemInfo [6] - Additional virtual item information
Auras/Buffs/Debuffs (UINT32 arrays)
aura [48] - Array of aura (buff/debuff) spell IDs on the unit
Index 1-48 contains spell IDs (0 = no aura in that slot)
auraFlags [6] - Bit flags for aura properties (positive, negative, cancelable, etc.)
Each UINT32 contains flags for 8 auras (4 bits per aura)
auraLevels [12] - Aura caster levels
Each UINT32 contains 4 aura levels (8 bits per level)
auraApplications [12] - Aura stack counts
Each UINT32 contains 4 aura stacks (8 bits per stack)
Resistances (UINT32 arrays)
resistances [7] - Resistance values for all schools
Index 1: Armor (physical resistance)
Index 2: Holy resistance
Index 3: Fire resistance
Index 4: Nature resistance
Index 5: Frost resistance
Index 6: Shadow resistance
Index 7: Arcane resistance
Spell Power Modifiers (FLOAT arrays)
powerCostModifier [7] - Flat mana cost modifications per school
Index 1-7: Physical, Holy, Fire, Nature, Frost, Shadow, Arcane
powerCostMultiplier [7] - Percent mana cost modifications per school
Index 1-7: Physical, Holy, Fire, Nature, Frost, Shadow, Arcane
Examples
Health Monitoring
-- Monitor target health percentage
local health = GetUnitField("target", "health")
local maxHealth = GetUnitField("target", "maxHealth")
local healthPct = (health / maxHealth) * 100
print("Target health: " .. healthPct .. "%")
Checking Auras
-- Check if target has a specific debuff
local auras = GetUnitField("target", "aura")
local CURSE_OF_AGONY = 980

for i, spellId in ipairs(auras) do
    if spellId == CURSE_OF_AGONY then
        print("Target has Curse of Agony!")
        break
    end
end
Reading Resistances
-- Get all player resistances
local resistances = GetUnitField("player", "resistances")
print("Armor: " .. resistances[1])
print("Holy resistance: " .. resistances[2])
print("Fire resistance: " .. resistances[3])
print("Nature resistance: " .. resistances[4])
print("Frost resistance: " .. resistances[5])
print("Shadow resistance: " .. resistances[6])
print("Arcane resistance: " .. resistances[7])
Checking Combat State
-- Check if unit is in combat (flags field bit check)
local flags = GetUnitField("target", "flags")
local UNIT_FLAG_IN_COMBAT = 0x00080000
local inCombat = bit.band(flags, UNIT_FLAG_IN_COMBAT) ~= 0
print("In combat: " .. tostring(inCombat))
Monitoring Cast Speed
-- Check your current cast speed modifier
local modCastSpeed = GetUnitField("player", "modCastSpeed")
-- 1.0 = normal, 0.9 = 10% faster, 1.1 = 10% slower
print("Cast speed modifier: " .. modCastSpeed)
Attack Power Info
-- Get your attack power
local ap = GetUnitField("player", "attackPower")
local apMods = GetUnitField("player", "attackPowerMods")
local apMult = GetUnitField("player", "attackPowerMultiplier")
print("Base AP: " .. ap)
print("AP Mods: " .. apMods)
print("AP Multiplier: " .. apMult)
Pet Information
-- Check pet experience
if UnitExists("pet") then
    local petXP = GetUnitField("pet", "petExperience")
    local petNextXP = GetUnitField("pet", "petNextLevelExp")
    local progress = (petXP / petNextXP) * 100
    print("Pet XP: " .. progress .. "%")
end
Notes
GUID fields return numbers but represent 64-bit values. Lua handles these as doubles.
Array indices are 1-based (Lua convention), not 0-based.
Returns nil if the unit doesn't exist or the field cannot be read.
Some fields may require specific game state to be meaningful (e.g., pet fields only work when you have a pet).
Unit flags and other bit fields require bitwise operations to interpret properly.
Related Functions
GetUnitData(unitToken) - Get all fields at once
GetUnitField(unitToken, fieldName) - Get a single field efficiently
GetSpellModifiers(spellId, modifierType) - Get spell modifiers
GetItemStats(itemId) - Get item data
GetSpellRec(spellId) - Get spell data
